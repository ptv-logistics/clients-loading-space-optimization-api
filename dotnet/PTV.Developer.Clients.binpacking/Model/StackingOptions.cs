/*
 * Loading Optimization
 *
 * With the Bin Packing service you can pack a number of items of various types into a number of bins of various types.
 *
 * The version of the OpenAPI document: 1.2
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.binpacking.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.binpacking.Model
{
    /// <summary>
    /// Defines all stacking options to be considered during the packing algorithm.
    /// </summary>
    [DataContract(Name = "StackingOptions")]
    public partial class StackingOptions : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StackingOptions" /> class.
        /// </summary>
        /// <param name="stackingRestrictions">Defines all the stacking restrictions between items..</param>
        /// <param name="stackOnTopOfNextStops">Specifies if it is allowed to stack items of a stop above items of the next stops. Only relevant if unloadingSequence is used. (default to false).</param>
        /// <param name="stackOnTopOfMultipleStacks">Specifies whether larger items can be placed across multiple adjacent stacks of the same height, even if those stacks contain different items. By default (when false), items can only be stacked on top of adjacent stacks containing the same items.  (default to false).</param>
        public StackingOptions(List<StackingRestrictions> stackingRestrictions = default(List<StackingRestrictions>), bool? stackOnTopOfNextStops = false, bool? stackOnTopOfMultipleStacks = false)
        {
            this.StackingRestrictions = stackingRestrictions;
            // use default value if no "stackOnTopOfNextStops" provided
            this.StackOnTopOfNextStops = stackOnTopOfNextStops ?? false;
            // use default value if no "stackOnTopOfMultipleStacks" provided
            this.StackOnTopOfMultipleStacks = stackOnTopOfMultipleStacks ?? false;
        }

        /// <summary>
        /// Defines all the stacking restrictions between items.
        /// </summary>
        /// <value>Defines all the stacking restrictions between items.</value>
        [DataMember(Name = "stackingRestrictions", EmitDefaultValue = false)]
        public List<StackingRestrictions> StackingRestrictions { get; set; }

        /// <summary>
        /// Specifies if it is allowed to stack items of a stop above items of the next stops. Only relevant if unloadingSequence is used.
        /// </summary>
        /// <value>Specifies if it is allowed to stack items of a stop above items of the next stops. Only relevant if unloadingSequence is used.</value>
        /// <example>false</example>
        [DataMember(Name = "stackOnTopOfNextStops", EmitDefaultValue = true)]
        public bool? StackOnTopOfNextStops { get; set; }

        /// <summary>
        /// Specifies whether larger items can be placed across multiple adjacent stacks of the same height, even if those stacks contain different items. By default (when false), items can only be stacked on top of adjacent stacks containing the same items. 
        /// </summary>
        /// <value>Specifies whether larger items can be placed across multiple adjacent stacks of the same height, even if those stacks contain different items. By default (when false), items can only be stacked on top of adjacent stacks containing the same items. </value>
        /// <example>false</example>
        [DataMember(Name = "stackOnTopOfMultipleStacks", EmitDefaultValue = true)]
        public bool? StackOnTopOfMultipleStacks { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class StackingOptions {\n");
            sb.Append("  StackingRestrictions: ").Append(StackingRestrictions).Append("\n");
            sb.Append("  StackOnTopOfNextStops: ").Append(StackOnTopOfNextStops).Append("\n");
            sb.Append("  StackOnTopOfMultipleStacks: ").Append(StackOnTopOfMultipleStacks).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
