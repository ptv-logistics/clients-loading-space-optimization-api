/*
 * Loading Optimization
 * With the Bin Packing service you can pack a number of items of various types into a number of bins of various types.
 *
 * The version of the OpenAPI document: 1.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ptvgroup.developer.client.binpacking.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.ptvgroup.developer.client.binpacking.model.StackingRestrictions;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import com.ptvgroup.developer.client.binpacking.ApiClient;
/**
 * Defines all stacking options to be considered during the packing algorithm.
 */
@JsonPropertyOrder({
  StackingOptions.JSON_PROPERTY_STACKING_RESTRICTIONS,
  StackingOptions.JSON_PROPERTY_STACK_ON_TOP_OF_NEXT_STOPS,
  StackingOptions.JSON_PROPERTY_STACK_ON_TOP_OF_MULTIPLE_STACKS
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T13:28:30.257776203Z[Etc/UTC]", comments = "Generator version: 7.8.0")
public class StackingOptions {
  public static final String JSON_PROPERTY_STACKING_RESTRICTIONS = "stackingRestrictions";
  private List<StackingRestrictions> stackingRestrictions = new ArrayList<>();

  public static final String JSON_PROPERTY_STACK_ON_TOP_OF_NEXT_STOPS = "stackOnTopOfNextStops";
  private Boolean stackOnTopOfNextStops = false;

  public static final String JSON_PROPERTY_STACK_ON_TOP_OF_MULTIPLE_STACKS = "stackOnTopOfMultipleStacks";
  private Boolean stackOnTopOfMultipleStacks = false;

  public StackingOptions() { 
  }

  public StackingOptions stackingRestrictions(List<StackingRestrictions> stackingRestrictions) {
    this.stackingRestrictions = stackingRestrictions;
    return this;
  }

  public StackingOptions addStackingRestrictionsItem(StackingRestrictions stackingRestrictionsItem) {
    if (this.stackingRestrictions == null) {
      this.stackingRestrictions = new ArrayList<>();
    }
    this.stackingRestrictions.add(stackingRestrictionsItem);
    return this;
  }

  /**
   * Defines all the stacking restrictions between items.
   * @return stackingRestrictions
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STACKING_RESTRICTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<StackingRestrictions> getStackingRestrictions() {
    return stackingRestrictions;
  }


  @JsonProperty(JSON_PROPERTY_STACKING_RESTRICTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStackingRestrictions(List<StackingRestrictions> stackingRestrictions) {
    this.stackingRestrictions = stackingRestrictions;
  }


  public StackingOptions stackOnTopOfNextStops(Boolean stackOnTopOfNextStops) {
    this.stackOnTopOfNextStops = stackOnTopOfNextStops;
    return this;
  }

  /**
   * Specifies if it is allowed to stack items of a stop above items of the next stops. Only relevant if unloadingSequence is used.
   * @return stackOnTopOfNextStops
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STACK_ON_TOP_OF_NEXT_STOPS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Boolean getStackOnTopOfNextStops() {
    return stackOnTopOfNextStops;
  }


  @JsonProperty(JSON_PROPERTY_STACK_ON_TOP_OF_NEXT_STOPS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStackOnTopOfNextStops(Boolean stackOnTopOfNextStops) {
    this.stackOnTopOfNextStops = stackOnTopOfNextStops;
  }


  public StackingOptions stackOnTopOfMultipleStacks(Boolean stackOnTopOfMultipleStacks) {
    this.stackOnTopOfMultipleStacks = stackOnTopOfMultipleStacks;
    return this;
  }

  /**
   * Specifies whether larger items can be placed across multiple adjacent stacks of the same height, even if those stacks contain different items. By default (when false), items can only be stacked on top of adjacent stacks containing the same items. 
   * @return stackOnTopOfMultipleStacks
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STACK_ON_TOP_OF_MULTIPLE_STACKS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Boolean getStackOnTopOfMultipleStacks() {
    return stackOnTopOfMultipleStacks;
  }


  @JsonProperty(JSON_PROPERTY_STACK_ON_TOP_OF_MULTIPLE_STACKS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStackOnTopOfMultipleStacks(Boolean stackOnTopOfMultipleStacks) {
    this.stackOnTopOfMultipleStacks = stackOnTopOfMultipleStacks;
  }


  /**
   * Return true if this StackingOptions object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    StackingOptions stackingOptions = (StackingOptions) o;
    return Objects.equals(this.stackingRestrictions, stackingOptions.stackingRestrictions) &&
        Objects.equals(this.stackOnTopOfNextStops, stackingOptions.stackOnTopOfNextStops) &&
        Objects.equals(this.stackOnTopOfMultipleStacks, stackingOptions.stackOnTopOfMultipleStacks);
  }

  @Override
  public int hashCode() {
    return Objects.hash(stackingRestrictions, stackOnTopOfNextStops, stackOnTopOfMultipleStacks);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class StackingOptions {\n");
    sb.append("    stackingRestrictions: ").append(toIndentedString(stackingRestrictions)).append("\n");
    sb.append("    stackOnTopOfNextStops: ").append(toIndentedString(stackOnTopOfNextStops)).append("\n");
    sb.append("    stackOnTopOfMultipleStacks: ").append(toIndentedString(stackOnTopOfMultipleStacks)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `stackingRestrictions` to the URL query string
    if (getStackingRestrictions() != null) {
      for (int i = 0; i < getStackingRestrictions().size(); i++) {
        if (getStackingRestrictions().get(i) != null) {
          joiner.add(getStackingRestrictions().get(i).toUrlQueryString(String.format("%sstackingRestrictions%s%s", prefix, suffix,
          "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
    }

    // add `stackOnTopOfNextStops` to the URL query string
    if (getStackOnTopOfNextStops() != null) {
      joiner.add(String.format("%sstackOnTopOfNextStops%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getStackOnTopOfNextStops()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `stackOnTopOfMultipleStacks` to the URL query string
    if (getStackOnTopOfMultipleStacks() != null) {
      joiner.add(String.format("%sstackOnTopOfMultipleStacks%s=%s", prefix, suffix, URLEncoder.encode(ApiClient.valueToString(getStackOnTopOfMultipleStacks()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    return joiner.toString();
  }
}

